// Generated by CoffeeScript 1.12.8
(function() {
  var B, S, U, age_goo, can_eat, decay, defaults, direct_snake, eat, fresh_goo, goo_list_and_scene, grow, img_and_scene, img_list_and_scene, is_close, is_dead, is_dir, is_opposite_dir, is_rotten, is_self_colliding, is_wall_colliding, mk_goo, mk_pit, mk_posn, mk_snake, next_head, next_pit, posn_move, random, render_end, render_pit, renew, rot, slither, snake_and_scene, snake_body, snake_change_dir, snake_head, start, world_change_dir;

  U = this._ || require('underscore');

  B = this.bigbang || require('bigbang');

  S = typeof exports !== "undefined" && exports !== null ? exports : this.snake || (this.snake = {});

  S.mk_pit = mk_pit = function(snake, goos, opts) {
    return {
      snake: snake,
      goos: goos,
      opts: opts
    };
  };

  S.mk_snake = mk_snake = function(dir, segs) {
    return {
      dir: dir,
      segs: segs
    };
  };

  S.mk_goo = mk_goo = function(loc, expire) {
    return {
      loc: loc,
      expire: expire
    };
  };

  S.mk_posn = mk_posn = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  S.defaults = defaults = {
    FPS: 10,
    EXPIRATION_TIME: 50,
    MAX_GOO: 5,
    SEG_SIZE: 30,
    ENDGAME_TEXT_SIZE: '8em',
    BODY_IMG: null,
    CANVAS: null,
    GOO_IMG: null,
    HEAD_LEFT_IMG: null,
    HEAD_UP_IMG: null,
    HEAD_RIGHT_IMG: null,
    HEAD_DOWN_IMG: null,
    WIDTH: 30,
    HEIGHT: 30
  };

  S.start = start = function(opts) {
    var bb_opts, i, o, w;
    o = U.extend({}, defaults, opts);
    o.WIDTH_PX = o.SEG_SIZE * o.WIDTH;
    o.HEIGHT_PX = o.SEG_SIZE * o.HEIGHT;
    o.WIDTH_PX_HALF = Math.round(o.WIDTH_PX / 2);
    o.HEIGHT_PX_HALF = Math.round(o.HEIGHT_PX / 2);
    o.MT_SCENE = B.empty_scene(o.WIDTH_PX, o.HEIGHT_PX);
    w = mk_pit(mk_snake('right', [mk_posn(1, 1)]), (function() {
      var j, results;
      results = [];
      for (i = j = 1; j <= 6; i = ++j) {
        results.push(fresh_goo(o));
      }
      return results;
    })(), o);
    bb_opts = {
      canvas: o.CANVAS,
      fps: o.FPS,
      world: w,
      on_tick: next_pit,
      on_key: direct_snake,
      to_draw: render_pit,
      stop_when: is_dead,
      last_draw: render_end,
      queue: 1
    };
    return B(bb_opts);
  };

  S.next_pit = next_pit = function(w) {
    var goo_to_eat;
    goo_to_eat = can_eat(w.snake, w.goos);
    if (goo_to_eat) {
      return mk_pit(grow(w.snake), age_goo(eat(w.goos, goo_to_eat, w.opts), w.opts), w.opts);
    } else {
      return mk_pit(slither(w.snake), age_goo(w.goos, w.opts), w.opts);
    }
  };

  S.direct_snake = direct_snake = function(w, k) {
    if (is_dir(k)) {
      return world_change_dir(w, k);
    } else {
      return w;
    }
  };

  S.render_pit = render_pit = function(w) {
    return snake_and_scene(w.snake, goo_list_and_scene(w.goos, w.opts.MT_SCENE, w.opts), w.opts);
  };

  S.is_dead = is_dead = function(w) {
    return is_self_colliding(w.snake) || is_wall_colliding(w.snake, w.opts);
  };

  S.render_end = render_end = function(w) {
    return B.place_text('Game over', w.opts.WIDTH_PX_HALF, w.opts.HEIGHT_PX_HALF, w.opts.ENDGAME_TEXT_SIZE, 'black', render_pit(w));
  };

  S.can_eat = can_eat = function(sn, goos) {
    return U.find(goos, function(x) {
      return is_close(snake_head(sn), x);
    });
  };

  S.eat = eat = function(goos, goo, opts) {
    return [fresh_goo(opts)].concat(U.without(goos, goo));
  };

  S.is_close = is_close = function(seg, goo) {
    return U.isEqual(seg, goo.loc);
  };

  S.grow = grow = function(sn) {
    return mk_snake(sn.dir, [next_head(sn)].concat(sn.segs));
  };

  S.slither = slither = function(sn) {
    return mk_snake(sn.dir, [next_head(sn)].concat(U.initial(sn.segs)));
  };

  S.next_head = next_head = function(sn) {
    var dir, head;
    head = snake_head(sn);
    dir = sn.dir;
    switch (false) {
      case dir !== 'up':
        return posn_move(head, 0, -1);
      case dir !== 'down':
        return posn_move(head, 0, 1);
      case dir !== 'left':
        return posn_move(head, -1, 0);
      case dir !== 'right':
        return posn_move(head, 1, 0);
    }
  };

  S.posn_move = posn_move = function(p, dx, dy) {
    return mk_posn(p.x + dx, p.y + dy);
  };

  S.age_goo = age_goo = function(goos, opts) {
    return rot(renew(goos, opts));
  };

  S.renew = renew = function(goos, opts) {
    return U.map(goos, function(x) {
      if (is_rotten(x)) {
        return fresh_goo(opts);
      } else {
        return x;
      }
    });
  };

  S.rot = rot = function(goos) {
    return U.map(goos, decay);
  };

  S.is_rotten = is_rotten = function(goo) {
    return goo.expire === 0;
  };

  S.decay = decay = function(goo) {
    return mk_goo(goo.loc, goo.expire - 1);
  };

  S.fresh_goo = fresh_goo = function(opts) {
    var r, x, y;
    r = opts.random || random;
    x = r(1, opts.WIDTH - 1);
    y = r(1, opts.HEIGHT - 1);
    return mk_goo(mk_posn(x, y), opts.EXPIRATION_TIME);
  };

  S.is_dir = is_dir = function(x) {
    return x === 'up' || x === 'down' || x === 'left' || x === 'right';
  };

  S.world_change_dir = world_change_dir = function(w, d) {
    var sn;
    sn = w.snake;
    if (is_opposite_dir(sn.dir, d) && sn.segs.length > 1) {
      return B.stop_with(w);
    } else {
      return mk_pit(snake_change_dir(sn, d), w.goos, w.opts);
    }
  };

  S.is_opposite_dir = is_opposite_dir = function(d1, d2) {
    return (d1 === 'up' && d2 === 'down') || (d1 === 'down' && d2 === 'up') || (d1 === 'left' && d2 === 'right') || (d1 === 'right' && d2 === 'left');
  };

  S.snake_and_scene = snake_and_scene = function(sn, scene, opts) {
    var img, sn_body_scene;
    sn_body_scene = img_list_and_scene(snake_body(sn), opts.BODY_IMG, scene, opts);
    img = (function() {
      switch (sn.dir) {
        case 'up':
          return opts.HEAD_UP_IMG;
        case 'down':
          return opts.HEAD_DOWN_IMG;
        case 'left':
          return opts.HEAD_LEFT_IMG;
        case 'right':
          return opts.HEAD_RIGHT_IMG;
      }
    })();
    return img_and_scene(snake_head(sn), img, sn_body_scene, opts);
  };

  S.goo_list_and_scene = goo_list_and_scene = function(goos, scene, opts) {
    var posns;
    posns = U.map(goos, function(x) {
      return x.loc;
    });
    return img_list_and_scene(posns, opts.GOO_IMG, scene, opts);
  };

  S.img_list_and_scene = img_list_and_scene = function(posns, img, scene, opts) {
    var f;
    f = function(s, p) {
      return img_and_scene(p, img, s, opts);
    };
    return U.reduce(posns, f, scene);
  };

  S.img_and_scene = img_and_scene = function(posn, img, scene, opts) {
    return B.place_image(img, posn.x * opts.SEG_SIZE, posn.y * opts.SEG_SIZE, scene);
  };

  S.is_self_colliding = is_self_colliding = function(sn) {
    return U.some(snake_body(sn), function(x) {
      return U.isEqual(x, snake_head(sn));
    });
  };

  S.is_wall_colliding = is_wall_colliding = function(sn, opts) {
    var x, y;
    x = snake_head(sn).x;
    y = snake_head(sn).y;
    return x === 0 || x === opts.WIDTH || y === 0 || y === opts.HEIGHT;
  };

  S.snake_head = snake_head = function(sn) {
    return U.first(sn.segs);
  };

  S.snake_body = snake_body = function(sn) {
    return U.rest(sn.segs);
  };

  S.snake_change_dir = snake_change_dir = function(sn, d) {
    return mk_snake(d, sn.segs);
  };

  S.random = random = function(min, max) {
    return Math.round(Math.random() * (max - min) + min);
  };

}).call(this);
